
#define number_of_ticks 10;
#define number_of_nodes 3;
#define honest -1;
#define malicious -2;

#alphabet timer {tick};
#alphabet node {readytosync, tick};
#alphabet node_forker {readytosync, tick};
#alphabet node_doubleproducer {readytosync, tick};

var blockPool[number_of_ticks * number_of_nodes * 2];
var nextSlot = 1;

var firstBlock[number_of_nodes];
var chainLength[number_of_nodes];
//var finished[number_of_nodes];
var forkChainFirstBlock[number_of_nodes];
var forkChainLength[number_of_nodes];

var globalTime = 0;

var processHonesty = [honest(number_of_nodes)];

node(i) = 
	[globalTime % number_of_nodes == i](produceblock.i{
		blockPool[nextSlot] = firstBlock[i];
		firstBlock[i] = nextSlot;
		nextSlot++;
		chainLength[i]++;
	} -> readytosync -> timer(i))
	[]
	[globalTime % number_of_nodes != i](readytosync -> synchronize.i{
		if (chainLength[i] < chainLength[globalTime % number_of_nodes]) {
			firstBlock[i] = firstBlock[globalTime % number_of_nodes];
			chainLength[i]++;
		}
	} -> timer(i));



timer(i) = 
		[i == 0 && globalTime < number_of_ticks] (tick -> increment{globalTime++;} -> tick -> node(i))
			[]
		[i != 0 && globalTime < number_of_ticks] (tick -> tick -> node(i));
		
system_normal = (||i:{0..number_of_nodes - 1} @ (node(i)));

#define allconsensus (firstBlock[0] == firstBlock[1]) && (firstBlock[1] == firstBlock[2]) && (globalTime == number_of_ticks);
#assert system_normal reaches allconsensus;

node_forker(i) = 
	[globalTime % number_of_nodes == i](produceblock.i{
		blockPool[nextSlot] = firstBlock[i];
		firstBlock[i] = nextSlot;
		nextSlot++;
		chainLength[i]++;
	} -> readytosync -> timer_forker(i))
	[]
	[globalTime % number_of_nodes != i](readytosync -> synchronize.i{
		if (globalTime < 3) {
			firstBlock[i] = firstBlock[globalTime % number_of_nodes];
			chainLength[i]++;
		}
	} -> timer_forker(i));
	
timer_forker(i) = 
		[i == 0 && globalTime < number_of_ticks] (tick -> increment{globalTime++;} -> tick -> node_forker(i))
			[]
		[i != 0 && globalTime < number_of_ticks] (tick -> tick -> node_forker(i));
	
system_minorityfork = node(0) || node(1) || node_forker(2);
#define honestconsensus (firstBlock[0] == firstBlock[1]) && (globalTime == number_of_ticks);
#define honestwinlongestchain (firstBlock[0] == firstBlock[1]) && (chainLength[0] > chainLength[2] && chainLength[0] > forkChainLength[2]) && (globalTime == number_of_ticks);
#assert system_minorityfork reaches allconsensus;
#assert system_minorityfork reaches honestconsensus;
#assert system_minorityfork reaches honestwinlongestchain;

node_doubleproducer(i) = 
	[globalTime % number_of_nodes == i](produceblock.i{
		blockPool[nextSlot] = firstBlock[i];
		firstBlock[i] = nextSlot;
		nextSlot++;
		chainLength[i]++;
	} -> produceforkblock.i{
		blockPool[nextSlot] = forkChainFirstBlock[i];
		forkChainFirstBlock[i] = nextSlot;
		nextSlot++;
		forkChainLength[i]++;
	} -> readytosync -> timer_doubleproducer(i))
	[]
	[globalTime % number_of_nodes != i](readytosync -> synchronize.i{
		if (globalTime < 3) {
			firstBlock[i] = firstBlock[globalTime % number_of_nodes];
			chainLength[i]++;
			
			forkChainFirstBlock[i] = firstBlock[globalTime % number_of_nodes];
			forkChainLength[i]++;
		}
	} -> timer_doubleproducer(i));
	
timer_doubleproducer(i) = 
		[i == 0 && globalTime < number_of_ticks] (tick -> increment{globalTime++;} -> tick -> node_doubleproducer(i))
			[]
		[i != 0 && globalTime < number_of_ticks] (tick -> tick -> node_doubleproducer(i));
		
system_doubleproduction = node(0) || node(1) || node_doubleproducer(2);
#assert system_doubleproduction reaches allconsensus;
#assert system_doubleproduction reaches honestconsensus;
#assert system_doubleproduction reaches honestwinlongestchain;